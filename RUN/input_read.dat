# Running the code on Enrico's Mac Air
#    /opt/local/bin/mpiexec-mpich-mp -np 4 ./maske input.dat


# ===== SET UNIVERSE OF SUB-COMMUNICATORS ========

# command structure: subcomm Nsubcomms name1 Nproc1 lmp_yes/no name2 Nproc2 .... nameN NprocN
# NB: the first subcomm should always be lmp_yes, otherwise thermos cannot be produced
subcomm 4 Antonello 2 lmp_yes 123 Bernini 2 lmp_yes 1234



# ===== READ CHEMISTRY DATA BASE ========

# Load chemistry database file, containing molecule types, reactions, and mechanisms
chemDB chemDB.dat



# ===== LIST REAL AND TRIAL PARTICLE TYPES TO BE USED IN THE SIM =======

real_types 1 2 3
trial_types 4 5 


# ========= INITIALISE LAMMPS AND LOAD INITIAL CONFIGURATION =========

lammps all  units nano
lammps all  atom_style sphere
lammps all  boundary p p p
lammps all  region boxfoo block -100 100 -100 100 -100 100 units box
lammps all  create_box  5 boxfoo
lammps all  read_dump ../../start_configs/dump.pour 21 x y z box yes add yes

#lammps all  displace_atoms all random 0.0050 0.0050 0.0080 123224

lammps all   variable 	Diam equal 0.61692	#for C3S
lammps all   set	type 1 diameter $(v_Diam)



#===== Potentials, neighbours, and minimiser style

lammps all   pair_style table linear 1000
lammps all   pair_coeff * * table.potential ENRICO


lammps all  neighbor	.05 bin
lammps all  neigh_modify	delay 0
lammps all  neigh_modify	exclude type 4 4

lammps all min_style quickmin
lammps all min_modify dmax .001 5 5 5




# ======== CONSTANTS IN LAMMPS UNITS
kB  0.0138064852       # Boltzmann, in nm2 ag ns-2 K-1
hpl  0.000662607004   # Plank, in nm2 ag / ns





# =========== DEFINE LAMMPS GROUPS TO BE USED BY MASKE FIXES (delete, nucleate, etc)

lammps all   variable midy equal (yhi+ylo)/2
lammps all   variable topl equal zlo+1.5*v_Diam
lammps all region left_box block INF INF INF $(v_midy) $(v_topl) INF
lammps all region right_box block INF INF $(v_midy) INF $(v_topl) INF
lammps all group g_left region 	left_box
lammps all group g_right region 	right_box

lammps all set group g_right type 2

lammps all run 0



# ===========   FREEZE BOTTOM LAYER
lammps all region		regbot block INF INF INF INF INF $(v_topl) units box
lammps all group gBot region 	regbot
lammps all fix freezeBot gBot setforce 0.0 0.0 0.0

lammps all set group  gBot type 3



# ===========   ADD COMPRESSION
#lammps all change_box all x scale 0.95 remap
#lammps all minimize 0 0 100 100
#lammps all run 0




#  ===========   DISSOLVE BOTTOM LAYER BY PARTICLE DELETION

#sol_start uniform 4 H2O 55 Ca .000 H3SiO4 0.0000 OH 0.0000 Temp 298 DH_A 0.51 DH_B 3.29 voidV 0 dV iso 1e5 dVvoidV 0  unitC 1e-24

sol_start uniform 4 H2O 55 Ca .000 H3SiO4 0.0000 OH 0.0000 Temp 298 DH_A 0.51 DH_B 3.29 voidV 0 dV iso 1e9 dVvoidV 0  unitC 1e-24


lammps all print "Solution started ok"   

fix KMC-free delete DelC3S Antonello 1 mech C3Sdel_apnet sol_in fixed uniform box sol_out uniform box+dV

fix KMC-free delete DelC3S2 Bernini 2 mech C3Sdel_apnet sol_in fixed uniform box sol_out uniform box+dV






# ======= NUCLEATION FIXES - approach based on stored regions, lattices, and minimise

# Stored commands are evaluated each time a KMC event is carried out. They can depend on variables which are evaluated during Krun, when the stored quantity is invoked. Hence the variables must exist in the subcomm that invokes the stored quantity during the relevant Krun


lammps 	all	variable Nxmid equal xlo+(xhi-xlo)/2   
lammps all variable Nzmid equal zlo+(zhi-zlo)/2  

store region nucLeft block INF $(v_Nxmid) INF INF INF INF units box
store region nucRight block $(v_Nxmid) INF INF INF INF $(v_Nzmid) units box

lammps	all	variable Lx equal (xhi-xlo)/2/10 
lammps	all	variable Ly equal (yhi-ylo)/10
lammps	all	variable Lz equal (zhi-zlo)/10 
lammps	all	variable scale equal v_Lx
lammps	all	variable aa2 equal v_Ly/v_Lx
lammps	all	variable aa3 equal v_Lz/v_Lx
store 	lattice	latNleft custom $(v_scale) a1 1.0 0.0 0.0 a2 0 $(v_aa2) 0.0 a3 0.0 0.0 $(v_aa3) basis 0.5 0.5 0.5
store 	DV	latNleft variable DVleft equal v_Lx*v_Ly*v_Lz

lammps	all	variable Qdmax equal v_Lx/100
lammps	all	variable DxMax equal v_Lx/2	# max displacements
lammps	all	variable DyMax equal v_Ly/2
lammps	all	variable DzMax equal v_Lz/2		
store minimize minLeft	0 0 1000 1000 min_modify dmax	$(v_Qdmax) $(v_DxMax) $(v_DyMax) $(v_DzMax) 

lammps	all	variable dLx equal v_Diam*1
lammps	all	variable dLy equal v_Diam*2
lammps	all	variable dLz equal v_Diam*3*0.82
lammps	all	variable dscale equal v_dLx
lammps	all	variable daa2 equal v_dLy/v_dLx
lammps	all	variable daa3 equal v_dLz/v_dLx
store	lattice latNright custom $(v_dscale) a1 1.0 0.0 0.0 a2 0 $(v_daa2) 0.0 a3 0.0 0.0 $(v_daa3) basis 0.5 0.5 0.5
store 	DV	latNright variable DVright equal v_dLx*v_dLy*v_dLz

lammps	all	variable dQdmax equal v_dLx/500
lammps	all	variable dDxMax equal v_dLx/2
lammps	all	variable dDyMax equal v_dLy/2
lammps	all	variable dDzMax equal v_dLz/2
store	minimize minRight 0 0 2000 2000 min_modify dmax	$(v_dQdmax) $(v_dDxMax) $(v_dDyMax) $(v_dDzMax)


fix KMC-free nucleate NucC3S_L Antonello nucLeft latNleft minLeft 4 1 sphere 0.61692 wei simple 1 mech C3Snuc_apnet sol_in fixed uniform box sol_out uniform box+dV

fix KMC-free nucleate NucC3S_R Bernini nucRight latNright minRight 5 2 sphere 0.61692 wei simple 1 mech C3Snuc_apnet sol_in fixed uniform box sol_out uniform box+dV





# ====== NUCLEATION FIXES

# the region_block starts with the definition of variables that will be recalculated in lammps every time the region is used. These variables can take box size as input to let the region adapt to the simulation box. The block is concluded with the region keyword, that defines the region in usual lammps terms. NB: this gives all lammps flexibility in defining regions and lattices. The region block is invoked by fix_nucleate at init, i.e. each time a KMC event is realised: continuous box deformations between KMC events are accounted for by automatic lattice distortions in fix_nucleate. Maske executes commands in block in order, except for min_modify and minimize in lattice, which are executed later during run, hence can be placed anywehre


# lattice id type lattice_constant(s) args origin
# 	type: only "prism" supported for now
#    lattice_constant(s) can be "scale"or "ncels"; they require 3 arguments, floating points. For "scale" the args are length of edges in xyz ,for ncels is number of subdivision or region the lattice will be applied to, in xyz 
# 	origin is where particles will be placed in cell, in cell's fractional coordinates (e.g. 0 0 0 = origin, 0.5 0.5 0.5 = middle). NB: if used in fix_nucleate and with a split != 1 1 1, the particle will be placed in an origin with fractional coords referred to the cell reduced by the split (e.g., if split 2 2 2 is used and origin 0.5 0.5 0.5, particles will be placed in the centres of all 8 sub-lattices produced by the split)


#lattice lat1 prism ncels 10 9.8 10.5 origin 0.5 0.5 0.5
#lattice lat2 prism ncels 10 10 10 origin 0.5 0.5 0.5

lammps all group gleftN region 	left_box
lammps all group grightN region 	right_box

lammps all group gleftN clear
lammps all group grightN clear



# the prism region is in fractional coords, so it changes during sim. Lattice is arranged so that its origin matches the origin of the prism region


#fix KMC-free nucleate NucC3S Antonello prism 0 1. 0 0.5 0 1. lattice lat1 split 1 1 1 types 2 3 group g_left_new sphere 0.61692 meshcf 1 wei 1 mech C3Snuc_apnet sol_in fixed uniform box sol_out uniform box+dV 

#fix KMC-free nucleate NucC3S2 Bernini prism 0 1. 0.5 1 0 1. lattice lat2 split 1 1 1 types 4 5 group g_right_new sphere 0.61692 meshcf 1 wei 1 mech C3Snuc_apnet sol_in fixed uniform box sol_out uniform box+dV


# below an example with static lammps region (which can also be sphere or else, but does not evolve with simulation box if that changes, e.g. due to stress relaxation). In this case, the lattice is referred to the simulation box, so it changes with it, leading to possible changes of lattice point position in region during simulation
# fix KMC-free nucleate NucC3S Antonello region left_box lattice lat1 split 1 types 2 3 group g_left_new sphere 0.61692 meshcf 1 mech C3Snuc_apnet sol_in fixed uniform box sol_out uniform box+dV




lammps all print "All fixes added"





# ========= DEFINE LAMMPS DUMPS AND THERMOS + VARIABLES ALSO FOR MASKE OUTPUT

lammps all variable N equal atoms
lammps all variable U equal epair
lammps all variable P equal press
 
#lammps all variable Nleft equal count(g_left)
#lammps all variable Nright equal count(g_right)

lammps all compute  PEall all pe/atom
#lammps all compute  PEl g_left pe/atom
#lammps all compute  PEr g_right pe/atom
#lammps all compute  PElt g_left reduce sum c_PEl
#lammps all compute  PErt g_right reduce sum c_PEr

# the lammps thermo must calculate all the thermo variables and compute you want to output via the MASKE's thermo
#lammps all thermo_style	custom step atoms vol epair press v_Nleft v_Nright c_PElt c_PErt
lammps all thermo_style	custom step atoms vol epair press 
#N_1 N_2 PE_1 PE_2
lammps all thermo 1000


thermo 10 thermo.txt conc_Ca conc_H3SiO4 conc_H2O conc_OH conc_C3S lmp_v_N lmp_v_U lmp_v_P 
#N_1 N_2 PE_1 PE_2


#tempdump all tD1 all custom 1 tempdump1 c_PEall c_PEr
#tempdump all tD2 all custom 1 tempdump2 c_PEl
#tempdump all tD3 all custom 1 tempdump3 c_PEr

dump Antonello D1 1 all     custom  dump.all id type x y z radius c_PEall
dump Bernini D2 1 all     custom  dump.all id type x y z radius c_PEall

#dump Antonello D2 10 1  custom  dump.left id type x y z radius 
#PE_1
#dump Bernini   D3 50  g_right custom  dump.right id type x y z radius c_PEr


# relax every_Nsteps mode args (for minimize, etol ftol maxiter maxeval min_style 
# min_modify_args;  for nvt, all args admitted by an nvt fix in lammps)
#example:      relax 10 minimize 0 0 1000 1000 quickmin dmax .01 20 20 20 
# relax R1 1 minimize 0 0 1000 1000 cg dmax 0.001 20 20 20 


#lammps Antonello dump Dt all custom 1 tdump id type x y z radius
#lammps Antonello dump_modify Dt every 1 first yes

# =============== running the KMC simulation
lammps all print "STARTING KRUN" 
Krun 40000000000


lammps Antonello print "\n SUCCESS \n"

